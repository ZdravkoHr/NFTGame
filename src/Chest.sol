// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import "./utils/Events.sol";
import "./utils/Errors.sol";

import {Coins} from "./Coins.sol";
import {Player} from "./Player.sol";
import {Item} from "./Item.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {VRFConsumerBaseV2} from "@chainlink/src/v0.8/vrf/VRFConsumerBaseV2.sol";
import {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import {VRFCoordinatorV2Interface} from "@chainlink/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";

contract Chest is VRFConsumerBaseV2, Ownable {
    using EnumerableSet for EnumerableSet.UintSet;

    // ~~~VRF stats~~~
    VRFCoordinatorV2Interface public immutable VRF;
    uint64 private immutable subID;
    bytes32 private immutable gasLane;
    uint32 private immutable callbackGasLimit;
    uint16 private constant REQUEST_CONFIRMATIONS = 3;
    uint32 private constant NUM_WORDS = 1;

    // ~~~Chest stats~~~
    // Types of rewards 
    enum PrizeType {
        Weapon, 
        Potion,
        Coin
    }

    struct Prize {
        uint256 amount;// Amount of the wining
        uint256 ID;// ID (for ERC1155)
    }

    EnumerableSet.UintSet private weaponChances;
    EnumerableSet.UintSet private potionChances;
    EnumerableSet.UintSet private coinChances;

    //@notice maps the type of the prize => it's id in the set => amount + ID (for ERC1155)
    mapping(PrizeType prizeType => mapping(uint256 ID => Prize)) public prizes;

    //@notice maps playerID => start of the week => is claimed
    mapping(uint256 playerID => mapping(uint256 time => bool claimed)) public claimed;

    uint256 private constant BIP = 1e5;// 100k, 1 == 0.001%
    uint256 private lastTimeCalled;// The last time that the VRF was called, set to the begining of the week.
    uint256 private currentNumber;//current lucky number, generated by the VRF
    uint256 private blockInterval; // used to prevent addressLottery manipulation
    uint256 private currentID;// ID if the request, not used for now
    uint256 private interval;// the interval at which the roll can happen, recomended --> 1 week

    Player private playerContract;
    Coins private coinsContract;
    Item private itemContract;

    constructor(
        address _vrf,
        address _player,
        address _coin,
        address _itemContract,
        uint64 _subscriptionId,
        bytes32 _gasLane, // keyHash
        uint256 _interval, // 1 week
        uint256 _blockInterval, // 1 day
        uint32 _callbackGasLimit,
        address _world
    ) VRFConsumerBaseV2(_vrf) Ownable(_world) {
        VRF = VRFCoordinatorV2Interface(_vrf);
        playerContract = Player(_player);
        coinsContract = Coins(_coin);
        itemContract = Item(_itemContract);
        gasLane = _gasLane;
        interval = _interval;
        subID = _subscriptionId;
        callbackGasLimit = _callbackGasLimit;
        blockInterval = _blockInterval;

        if (!weaponChances.add(0)) revert ChanceNotAdded();
        if (!potionChances.add(0)) revert ChanceNotAdded();
        if (!coinChances.add(0)) revert ChanceNotAdded();
    }
    
    /**
      @notice Owner function to add a chance to the existing sets
      @dev Adds 1 chance to the sets, used for gas saving purposes
      @param `itemType` - What set it is.
      @param `chance` - It's chance
      @param `amount` - How many will the user receive
      @param `ID` - What is the ID of the item, not used for coins
      */

    function addChance(PrizeType itemType, uint256 chance, uint256 amount, uint256 ID) external onlyOwner {
        _addChance(itemType, chance, amount, ID);
    }

    /**
      @notice Owner function to add multiple chances to the existing sets
      @dev Adds multiple chances to the sets, used for gas saving purposes
      @param `itemTypes` - What set it is.
      @param `chances` - It's chance
      @param `amounts` - How many will the user receive
      @param `IDs` - What is the ID of the item, not used for coins
      */
    function addChances(
        PrizeType[] calldata itemTypes,
        uint256[] calldata chances,
        uint256[] calldata amounts,
        uint256[] calldata IDs
    ) external onlyOwner {
        uint256 length = itemTypes.length;
        if (length != chances.length || length != amounts.length || length != IDs.length) {
            for (uint256 i; i < length; i++) {
                _addChance(itemTypes[i], chances[i], amounts[i], IDs[i]);
            }
        }
    }

    /**
      @notice Internal function to add chances to the existing sets
      @dev Adds a chance to a given set
      @param `itemType` - What set it is.
      @param `chance` - It's chance
      @param `amount` - How many will the user receive
      @param `ID` - What is the ID of the item, not used for coins
      */
    function _addChance(PrizeType itemType, uint256 chance, uint256 amount, uint256 ID) internal {
        if (chance > BIP) revert IncorrectChance();

        if (itemType == PrizeType.Weapon) {
            uint256 length = weaponChances.length();
            if (length > 0) {
                if (weaponChances.at(length - 1) >= chance) revert ChanceTooSmall();
            }
            prizes[itemType][length].amount = amount;
            prizes[itemType][length].ID = ID;
            if (!weaponChances.add(chance)) revert WeaponNotAdded(chance);
        } else if (itemType == PrizeType.Potion) {
            uint256 length = weaponChances.length();
            if (length > 0) {
                if (potionChances.at(length - 1) >= chance) revert ChanceTooSmall();
            }
            prizes[itemType][length].amount = amount;
            prizes[itemType][length].ID = ID;
            if (!potionChances.add(chance)) revert PotionNotAdded(chance);
        } else if (itemType == PrizeType.Coin) {
            uint256 length = weaponChances.length();
            if (length > 0) {
                if (coinChances.at(length - 1) >= chance) revert ChanceTooSmall();
            }
            prizes[itemType][length].amount = amount;
            if (!coinChances.add(chance)) revert CoinNotAdded(chance);
        } else {
            revert IncorrectItemType();
        }
        emit Events.ItemAdded(uint256(itemType), chance, ID, amount);
    }

    /*
      @notice claims the price for the current week
      @dev Uses the current weeks' random number and some other user specific vars to calculate a semi-random number.
      It is known as soon as this week's random number is generated.
      @param `playerID` - the ID of thye player
      */
    function claimPrize(uint256 playerID) external {
        if (claimed[playerID][lastTimeCalled]) revert AlreadyClaimed();
        if (playerContract.regesteredTime(playerID) - blockInterval > lastTimeCalled) revert TooLateToPlay();

        uint256 luckyNumber = uint256(bytes32(keccak256(abi.encodePacked(playerID, currentNumber))));
        uint256 itemType = luckyNumber % 3;
        uint256 itemChance = luckyNumber % BIP;
        uint256 item;
        Prize memory wonPrize;

        if (itemType == uint256(PrizeType.Weapon)) {
            item = _itemRoll(weaponChances, itemChance);
            wonPrize = prizes[PrizeType.Weapon][item];
            itemContract.mint(msg.sender, wonPrize.ID, wonPrize.amount, "");
        } else if (itemType == uint256(PrizeType.Potion)) {
            item = _itemRoll(potionChances, itemChance);
            wonPrize = prizes[PrizeType.Potion][item];
            itemContract.mint(msg.sender, wonPrize.ID, wonPrize.amount, "");
        } else {
            item = _itemRoll(coinChances, itemChance);
            coinsContract.mint(msg.sender, prizes[PrizeType.Coin][item].amount);
        }
        claimed[playerID][lastTimeCalled] = true;
    }

    /*
      @notice internal roll function to simplify `claimPrize`
      @dev returns the representative index of where the `chance` is. 
      Example -->  `0-10-20-30` `chance-13` it will return 1
      @param `set` - UnitSet representing the item
      @param `chance` - the number which the should the index match to 
      */
    function _itemRoll(EnumerableSet.UintSet storage set, uint256 chance) internal view returns (uint256) {
        uint256 length = set.length();
        for (uint256 i; i < length; i++) {
            if (set.at(i) <= chance) {
                if (set.at(set.length() - 1) == i) {
                    return i;
                } else if (set.at(i + 1) > chance) {
                    return i;
                }
                continue;
            }
        }
    }

    /*
      @notice roll this week's random number
      @dev maps week start to the ID
      */
    function roll() external {
        if (block.timestamp <= lastTimeCalled + interval) {
            revert TooEarly();
        }
        lastTimeCalled = (block.timestamp / interval) * interval;
        currentID = VRF.requestRandomWords(gasLane, subID, REQUEST_CONFIRMATIONS, callbackGasLimit, NUM_WORDS);
        emit Events.rollReqested(currentID);
    }

    /*
      @notice If the first revert an admin can save this week's raffle
      @dev Owner can change the VRF until he likes it, but he is expected not to do it
      */
    function adminRoll() external onlyOwner {
        lastTimeCalled = (block.timestamp / interval) * interval;
        currentID = VRF.requestRandomWords(gasLane, subID, REQUEST_CONFIRMATIONS, callbackGasLimit, NUM_WORDS);
    }

    /*
      @notice VRF return function 
      */
    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {
        currentNumber = randomWords[0];
        emit Events.NewRandomNumber(block.timestamp, randomWords[0]);
    }
}
